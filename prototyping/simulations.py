#!/usr/bin/env python3
"""
Geant4 Simulation Interface
===========================

Python wrapper for Geant4 photonuclear transmutation simulations.
Interfaces with local Geant4-11.3 installation for physics-accurate modeling.
"""

import subprocess
import json
import numpy as np
import tempfile
import shutil
from pathlib import Path
from typing import Dict, List, Tuple, Optional
import logging
from dataclasses import dataclass
import os
import time

from atomic_binder import AtomicDataBinder

@dataclass
class SimulationParameters:
    """Parameters for a Geant4 simulation run."""
    beam_energy_mev: float
    beam_current_ua: float  # microamps
    target_composition: Dict[str, float]  # isotope -> fraction
    target_mass_g: float
    target_density_g_cm3: float
    irradiation_time_s: float
    geometry_type: str = "cylindrical"

@dataclass
class SimulationResults:
    """Results from a Geant4 simulation."""
    total_reactions: int
    reaction_breakdown: Dict[str, int]
    gold_atoms_produced: int
    energy_deposited_mev: float
    simulation_time_s: float
    cpu_efficiency: float

class Geant4Interface:
    """Interface to Geant4 Monte Carlo simulations."""
    
    def __init__(self, geant4_dir: str = "C:\\Program Files\\Geant4-11.3"):
        """Initialize Geant4 interface."""
        self.geant4_dir = Path(geant4_dir)
        self.geant4_bin = self.geant4_dir / "bin"
        self.logger = logging.getLogger(__name__)
        
        # Working directory for simulations
        self.sim_dir = Path("simulations")
        self.sim_dir.mkdir(exist_ok=True)
        
        # Atomic data for cross-sections
        self.atomic_data = AtomicDataBinder()
          # Verify Geant4 installation
        self._verify_geant4_installation()
        
        self.logger.info("Geant4 interface initialized")
    
    def _verify_geant4_installation(self):
        """Verify that Geant4 is properly installed and accessible."""
        
        # Check if Geant4 directory exists
        if not self.geant4_dir.exists():
            self.logger.warning(f"Geant4 not found at {self.geant4_dir}, using analytical mode")
            return
          # Check for key executables (optional for analytical mode)
        import sys
        if sys.platform.startswith("win"):
            config_name = "geant4-config.cmd"
        else:
            config_name = "geant4-config"
            
        if not (self.geant4_bin / config_name).exists():
            self.logger.info(f"{config_name} not found, using analytical mode")
            return
        
        # Test basic Geant4 environment
        try:
            result = subprocess.run([
                str(self.geant4_bin / config_name), "--version"
            ], capture_output=True, text=True, timeout=10)
            
            if result.returncode == 0:
                version = result.stdout.strip()
                self.logger.info(f"Found Geant4 version: {version}")
            else:
                self.logger.warning("Failed to get Geant4 version, using analytical mode")
                
        except Exception as e:
            self.logger.warning(f"Geant4 verification failed: {e}, using analytical mode")
            # Continue with analytical simulation
    
    def generate_geant4_macro(self, params: SimulationParameters, 
                             output_file: str) -> str:
        """Generate Geant4 macro file for simulation."""
        
        macro_content = f"""# Photonuclear gold production simulation
# Generated by elemental-transmutator pipeline

# Initialize
/run/initialize

# Set up physics
/physics_lists/em/SeparatePhysics Electromagnetic
/physics_lists/hadron/SeparatePhysics PhotoNuclear

# Geometry setup
/detector/setTargetMaterial G4_Pb
/detector/setTargetSize {params.target_mass_g / params.target_density_g_cm3:.3f} cm3
/detector/setTargetDensity {params.target_density_g_cm3:.3f} g/cm3

# Beam setup  
/gun/particle gamma
/gun/energy {params.beam_energy_mev:.2f} MeV
/gun/position 0 0 -10 cm
/gun/direction 0 0 1

# Output setup
/analysis/setFileName {output_file}
/analysis/h1/set 1 100 0 30 MeV "Photon Energy Spectrum"
/analysis/h1/set 2 50 0 50 none "Reaction Products"

# Radiation source modeling
/run/printProgress 10000

# Run simulation
/run/beamOn {int(params.beam_current_ua * params.irradiation_time_s * 6.24e12)}

# Save results
/analysis/write
"""
        
        return macro_content
    
    def create_geometry_file(self, params: SimulationParameters) -> str:
        """Create Geant4 geometry description."""
        
        # For now, create a simplified cylindrical target
        # In production, this would be a full GDML file
        
        geometry_content = f"""// Photonuclear target geometry
// Target: {params.target_mass_g:.2f} g mixed target

#include "G4SystemOfUnits.hh"
#include "G4NistManager.hh"

// Target dimensions
const G4double targetMass = {params.target_mass_g} * g;
const G4double targetDensity = {params.target_density_g_cm3} * g/cm3;
const G4double targetVolume = targetMass / targetDensity;

// Cylindrical target (height = diameter)
const G4double targetRadius = pow(targetVolume / (2 * pi), 1.0/3.0);
const G4double targetHeight = 2 * targetRadius;

// Material composition
"""
        
        for isotope, fraction in params.target_composition.items():
            geometry_content += f"// {isotope}: {fraction:.3f}\n"
        
        return geometry_content
    
    def run_simulation(self, params: SimulationParameters, 
                      sim_name: str = None) -> SimulationResults:
        """Run a Geant4 simulation with given parameters."""
        
        if sim_name is None:
            sim_name = f"sim_{int(time.time())}"
        
        sim_path = self.sim_dir / sim_name
        sim_path.mkdir(exist_ok=True)
        
        self.logger.info(f"Starting simulation: {sim_name}")
        start_time = time.time()
        
        try:
            # Generate macro file
            macro_content = self.generate_geant4_macro(params, f"{sim_name}_output")
            macro_file = sim_path / f"{sim_name}.mac"
            
            with open(macro_file, 'w', encoding='utf-8') as f:
                f.write(macro_content)
            
            # For rapid prototyping, use analytical calculation instead of full Geant4
            # This allows testing the pipeline without waiting for Geant4 compilation
            results = self._run_analytical_simulation(params)
            
            # Save simulation metadata
            metadata = {
                'parameters': {
                    'beam_energy_mev': params.beam_energy_mev,
                    'beam_current_ua': params.beam_current_ua,
                    'target_composition': params.target_composition,
                    'target_mass_g': params.target_mass_g,
                    'irradiation_time_s': params.irradiation_time_s
                },
                'results': {
                    'total_reactions': results.total_reactions,
                    'gold_atoms_produced': results.gold_atoms_produced,
                    'energy_deposited_mev': results.energy_deposited_mev
                },
                'simulation_info': {
                    'name': sim_name,
                    'timestamp': time.time(),
                    'duration_s': results.simulation_time_s
                }
            }
            
            with open(sim_path / "metadata.json", 'w', encoding='utf-8') as f:
                json.dump(metadata, f, indent=2)
            
            self.logger.info(f"Simulation completed: {results.gold_atoms_produced} Au atoms")
            return results
            
        except Exception as e:
            self.logger.error(f"Simulation failed: {e}")
            raise
    
    def _run_analytical_simulation(self, params: SimulationParameters) -> SimulationResults:
        """Run analytical calculation as Geant4 surrogate for rapid prototyping."""
        
        start_time = time.time()
        
        # Calculate photon fluence
        # Beam power: P = I * E (microamps * MeV)
        beam_power_mev_per_s = params.beam_current_ua * 1e-6 * 6.24e12 * params.beam_energy_mev
        total_photons = beam_power_mev_per_s * params.irradiation_time_s / params.beam_energy_mev
        
        # Target area (assume beam covers full target)
        target_volume_cm3 = params.target_mass_g / params.target_density_g_cm3
        target_radius_cm = (target_volume_cm3 / (2 * np.pi))**(1/3)
        target_area_cm2 = np.pi * target_radius_cm**2
        
        fluence_per_cm2 = total_photons / target_area_cm2
        
        # Use atomic data to calculate reaction yields
        total_efficiency = self.atomic_data.calculate_gold_production_efficiency(
            params.target_composition, params.beam_energy_mev, fluence_per_cm2
        )
        
        # Calculate results
        gold_atoms_produced = int(total_efficiency * total_photons)
        
        # Energy deposition (simplified)
        energy_deposited_mev = total_photons * params.beam_energy_mev * 0.15  # ~15% deposition
        
        # Reaction breakdown (simplified)
        total_reactions = int(total_photons * 0.02)  # ~2% interaction probability
        reaction_breakdown = {
            'gamma_n': int(total_reactions * 0.7),
            'gamma_2n': int(total_reactions * 0.2),
            'gamma_alpha': int(total_reactions * 0.1)
        }
        
        simulation_time = time.time() - start_time
        
        return SimulationResults(
            total_reactions=total_reactions,
            reaction_breakdown=reaction_breakdown,
            gold_atoms_produced=gold_atoms_produced,
            energy_deposited_mev=energy_deposited_mev,
            simulation_time_s=simulation_time,
            cpu_efficiency=gold_atoms_produced / simulation_time if simulation_time > 0 else 0
        )
    
    def parameter_sweep(self, energy_range: Tuple[float, float], 
                       energy_steps: int,
                       target_compositions: List[Dict[str, float]],
                       dose_range_kgy: Tuple[float, float],
                       dose_steps: int) -> List[Dict]:
        """Run parameter sweep across energy, composition, and dose."""
        
        self.logger.info("Starting parameter sweep")
        
        # Generate parameter grid
        energies = np.linspace(energy_range[0], energy_range[1], energy_steps)
        doses_kgy = np.logspace(np.log10(dose_range_kgy[0]), np.log10(dose_range_kgy[1]), dose_steps)
        
        results = []
        total_runs = len(energies) * len(target_compositions) * len(doses_kgy)
        run_count = 0
        
        for energy in energies:
            for composition in target_compositions:
                for dose_kgy in doses_kgy:
                    run_count += 1
                    
                    # Convert dose to irradiation time
                    # 1 kGy ≈ 6.24e15 eV/g ≈ 1 hour at 10 μA, 15 MeV for 1g target
                    target_mass = 4.0  # grams
                    irradiation_time_s = dose_kgy * 3600  # Simplified conversion
                    
                    params = SimulationParameters(
                        beam_energy_mev=energy,
                        beam_current_ua=10.0,  # 10 microamps
                        target_composition=composition,
                        target_mass_g=target_mass,
                        target_density_g_cm3=11.3,  # Lead density
                        irradiation_time_s=irradiation_time_s
                    )
                    
                    try:
                        sim_results = self.run_simulation(params, f"sweep_{run_count:03d}")
                        
                        # Calculate yield metrics
                        gold_mass_mg = sim_results.gold_atoms_produced * 197 / 6.022e23 * 1000
                        energy_kwh = (params.beam_current_ua * 1e-6 * params.beam_energy_mev * 
                                    1.602e-19 * 1e6 * params.irradiation_time_s) / 3600000
                        
                        yield_per_kwh = gold_mass_mg / energy_kwh if energy_kwh > 0 else 0
                        
                        result = {
                            'run_id': run_count,
                            'beam_energy_mev': energy,
                            'target_composition': composition,
                            'dose_kgy': dose_kgy,
                            'gold_atoms_produced': sim_results.gold_atoms_produced,
                            'gold_mass_mg': gold_mass_mg,
                            'energy_kwh': energy_kwh,
                            'yield_mg_per_kwh': yield_per_kwh,
                            'total_reactions': sim_results.total_reactions,
                            'simulation_time_s': sim_results.simulation_time_s
                        }
                        
                        results.append(result)
                        
                        if run_count % 10 == 0:
                            self.logger.info(f"Completed {run_count}/{total_runs} runs")
                            
                    except Exception as e:
                        self.logger.error(f"Run {run_count} failed: {e}")
        
        # Save sweep results
        sweep_file = self.sim_dir / f"parameter_sweep_{int(time.time())}.json"
        with open(sweep_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2)
        
        self.logger.info(f"Parameter sweep completed: {len(results)} successful runs")
        return results
    
    def find_optimal_parameters(self, sweep_results: List[Dict]) -> Dict:
        """Find optimal parameters from sweep results."""
        
        if not sweep_results:
            raise ValueError("No sweep results provided")
        
        # Sort by yield per kWh
        sorted_results = sorted(sweep_results, key=lambda x: x['yield_mg_per_kwh'], reverse=True)
        optimal = sorted_results[0]
        
        self.logger.info(f"Optimal configuration: {optimal['yield_mg_per_kwh']:.6f} mg Au/kWh")
        
        return {
            'beam_energy_mev': optimal['beam_energy_mev'],
            'target_composition': optimal['target_composition'],
            'dose_kgy': optimal['dose_kgy'],
            'predicted_yield_mg_per_kwh': optimal['yield_mg_per_kwh'],
            'predicted_total_yield_mg': optimal['gold_mass_mg'],
            'energy_requirement_kwh': optimal['energy_kwh'],
            'optimization_confidence': len([r for r in sorted_results[:10] 
                                          if abs(r['yield_mg_per_kwh'] - optimal['yield_mg_per_kwh']) 
                                          < 0.1 * optimal['yield_mg_per_kwh']]) / 10
        }

def main():
    """Test Geant4 interface with parameter sweep."""
    logging.basicConfig(level=logging.INFO)
    
    interface = Geant4Interface()
    
    # Define parameter space
    energy_range = (10.0, 20.0)  # MeV
    energy_steps = 21  # 0.5 MeV steps
    
    target_compositions = [
        {'Pb-208': 1.0},
        {'Pb-208': 0.9, 'Bi-209': 0.1},
        {'Pb-208': 0.8, 'Bi-209': 0.15, 'Tl-203': 0.05}
    ]
    
    dose_range = (1.0, 100.0)  # kGy
    dose_steps = 20
    
    # Run parameter sweep
    results = interface.parameter_sweep(
        energy_range, energy_steps,
        target_compositions,
        dose_range, dose_steps
    )
    
    # Find optimal parameters
    optimal = interface.find_optimal_parameters(results)
    
    print("\n" + "="*60)
    print("GEANT4 PARAMETER SWEEP RESULTS")
    print("="*60)
    print(f"Optimal beam energy: {optimal['beam_energy_mev']:.1f} MeV")
    print(f"Optimal target: {optimal['target_composition']}")
    print(f"Optimal dose: {optimal['dose_kgy']:.1f} kGy")
    print(f"Predicted yield: {optimal['predicted_yield_mg_per_kwh']:.6f} mg Au/kWh")
    print(f"Total gold per run: {optimal['predicted_total_yield_mg']:.4f} mg")
    print(f"Energy requirement: {optimal['energy_requirement_kwh']:.3f} kWh")
    print(f"Optimization confidence: {optimal['optimization_confidence']:.2f}")
    print("="*60)
    
    return 0

if __name__ == '__main__':
    exit(main())
